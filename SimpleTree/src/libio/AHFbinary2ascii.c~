#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <stdint.h>

//=================================================================================
// This code aims at converting (and merging) binary _halos, _profiles,
// and _particles files generated by AHF when switching on -DAHFbinary
//
// This code also gives you the option to only convert those halo properties
// you are primarily interested in. But for that you need to adjust the
// part where the information is written commenting out those properties
// of no concern to you. Please adjust the two routines
//                   write_halos()   &   write_profiles()
// to best suit your needs. You are also able to filter out halos below a certain
// MassCut given on the commandline when starting this code.
//
// Note, none of the filtering works for _particles as this file does not contain
// any information about halo properties! Or to be more presice, fiddling with the
// _particles files is presently not supported.
//
// THIS CODE IS INDEPENDENT OF ANY AHF LIBRARY AND COULD BE COMPILED STAND-ALONE
//=================================================================================

#define VERBOSE
#define PROFILE_FOR_GNUPLOT  // will have blank lines separating each profile
#define SUSSEXBIGRUN

//===================================================================
// the headers for the ASCII output files
//===================================================================
#define HEADER_HALOS    "# up to you what to put here\n"
#define HEADER_PROFILES "# up to you what to put here\n"

//===================================================================
// global variables
//===================================================================
double MassCut; // haloes below this mass will not be written to ASCII

//===================================================================
// structures
//===================================================================
typedef uint64_t ptid_t;
typedef uint64_t hid_t;
typedef float double_t; 
typedef struct m_particle
{
  ptid_t ID;
  hid_t haloID;
} m_particle_t;

typedef struct particlelist
{
  ptid_t ID;
} particlelist_t;

typedef struct m_halo 
{
  ptid_t ID;
  uint32_t npart;
  double_t Mvir;
  double_t Rvir;
  double_t Xc;
  double_t Yc;
  double_t Zc;
  double_t VXc;
  double_t VYc;
  double_t VZc;
  particlelist_t *Particles;
} m_halo_t;

typedef struct halo {
  uint64_t ID;
  uint64_t hostHalo;
  uint32_t numSubStruct;
  double_t   Mvir;
  uint32_t npart;
  double_t   Xc;
  double_t   Yc;
  double_t   Zc;
  double_t   VXc;
  double_t   VYc;
  double_t   VZc;
  double_t   Rvir;
  double_t   Rmax;
  double_t   r2;
  double_t   mbp_offset;
  double_t   com_offset;
  double_t   Vmax;
  double_t   v_esc;
  double_t   sigV;
  double_t   lambda;
  double_t   lambdaE;
  double_t   Lx;
  double_t   Ly;
  double_t   Lz;
  double_t   b;
  double_t   c;
  double_t   Eax;
  double_t   Eay;
  double_t   Eaz;
  double_t   Ebx;
  double_t   Eby;
  double_t   Ebz;
  double_t   Ecx;
  double_t   Ecy;
  double_t   Ecz;
  double_t   ovdens;
  uint32_t nbins;
  double_t   fMhires;
  double_t   Ekin;
  double_t   Epot;
  double_t   SurfP;
  double_t   Phi0;
  double_t   cNFW;
} halo_t;
#define halo_t_size 180


typedef struct halo_profile {
  uint32_t      nbins;
  uint32_t      numColumns;
  double_t        *r;
  uint32_t      *npart;
  double_t        *M_in_r;
  double_t        *ovdens;
  double_t        *dens;
  double_t        *vcirc;
  double_t        *vesc;
  double_t        *sigv;
  double_t        *Lx;
  double_t        *Ly;
  double_t        *Lz;
  double_t        *b;
  double_t        *c;
  double_t        *Eax;
  double_t        *Eay;
  double_t        *Eaz;
  double_t        *Ebx;
  double_t        *Eby;
  double_t        *Ebz;
  double_t        *Ecx;
  double_t        *Ecy;
  double_t        *Ecz;
  double_t        *Ekin;
  double_t        *Epot;
  double_t        *M_gas;
  double_t        *M_star;
  double_t        *u_gas;
  double_t        *Z_gas_sh;
  double_t        *Z_star_sh;
} halo_profile_t;

//===================================================================
// PROTOTYPES
//===================================================================
void     convert                           (int , int , char **, char *);
void     convert_halos                     (FILE *, FILE *);
void     convert_profiles                  (FILE *, FILE *);
void     convert_particles                 (FILE *, FILE *);
void     alloc_profile                     (uint64_t, halo_profile_t *);
void     free_profile                      (halo_profile_t *);
uint64_t get_TotalNumHalos_from_particles  (int, char**);
void load_halo_catalogue_binary(char *halofile, char *partfile );
void  read_AHF_binary(FILE *fphalo, FILE *fppart, m_halo_t *mhalo);
//===================================================================
// routines copied from AHF to keep this code independent
//===================================================================
int     ReadULong          (FILE *, unsigned long *, int);
int     ReadInt            (FILE *, int           *, int);
int     ReadUInt           (FILE *, unsigned int  *, int);
int     ReadDouble_T         (FILE *, double_t        *, int);
#define TRUE  1
#define FALSE 0

/*=================================================================================================
 * write_halo(): FEEL FREE TO FILTER UNWANTED PROPERTIES BY COMMENTING THEM OUT
 *=================================================================================================*/



/*=================================================================================================
 * main()
 *=================================================================================================*/
int main(argc,argv)
int argc;
char **argv;
{   
  char   outfile[2048], **infile;
  char   prefix[2048], suffix[2048], suffix_ascii[2048];
  char halofile[2048],partfile[2048];
  int    i, slen, ftype, nfiles;

  fprintf(stderr,"======================================================================\n");
  fprintf(stderr,"======================================================================\n");
  
  sprintf(halofile,"/export/research/virgo/Boyd/testcurie/6.418_AHF_halos_cubepm_domain_0_halos.dat_bin");
  sprintf(partfile,"/export/research/virgo/Boyd/testcurie/6.418_AHF_halos_cubepm_domain_0_pids.dat_bin");
  load_halo_catalogue_binary(halofile, partfile);
}
  

void load_halo_catalogue_binary(char *halofile, char *partfile )
{
  FILE *fphalo,*fppart;
  uint64_t one;
  uint32_t onep;
  m_halo_t *mhalo;
  fphalo = fopen(halofile,"rb");
  fppart = fopen(partfile,"rb");

  read_AHF_binary(fphalo, fppart, mhalo);
  fclose(fppart);
  fclose(fphalo);
}
/*=================================================================================================
 * convert_halos()
 *=================================================================================================*/

void  read_AHF_binary(FILE *fphalo, FILE *fppart, m_halo_t *mhalo)
{
  uint64_t numHalos,counthalo,numHaloFromPartFile;
  uint32_t numColumns;
  uint64_t i,size;
  int32_t  one;
  int      swap=0;
  halo_t   halo;
  ptid_t ipart,id,npart;
#ifdef SUSSEXBIGRUN
  double_t         energy;
#endif
  // figure out swap status
  /* fread(&one, sizeof(int32_t), 1, fphalo); */
  /* if(one == 1)    */
  /*   swap = 0; */
  /* else */
  /*   swap = 1; */
  /* printf("halo: one = %d\n",one); */
  /* // figure out swap status */
  /* fread(&one, sizeof(int32_t), 1, fppart); */
  /* if(one == 1)    */
  /*    swap = 0; */
  /* else  */
  /*   swap = 1; */
  /* printf("part: one = %d\n",one); */
  swap = 0;
  /* ReadULong(fppart, &numHaloFromPartFile,   swap); */
  /* ReadUInt (fppart, &numColumns, swap); */
  /* printf("particlefile: nhalo = %llu\n",numHaloFromPartFile); */
  /* ReadULong(fphalo, &numHalos,   swap); */
  /* ReadUInt (fphalo, &numColumns, swap);  */
  /* printf("halofile: nhalo = %llu\n",numHalos); */
  /* exit(0); */


  // find the size of the file to calculate the total number of halos
  fseek(fphalo, 0L, SEEK_END);
  size = (uint64_t) ftell(fphalo);
  fseek(fphalo, 0L, SEEK_SET);
  numHalos = size/halo_t_size;
  //printf("size = %f; sizestruct %f; totalhalo %f\n",(float)size,(float)halo_t_size, (float)size/halo_t_size);
  printf("struct size = %d, actual size = %d \n",sizeof(struct halo), halo_t_size);
  mhalo = malloc(numHalos*sizeof(m_halo_t));
  // read in halo properties
  counthalo = 0;
  for(i=0; i<numHalos; i++) 
    {
      ReadULong(fphalo, &halo.ID,           swap);    // ID(1)
      ReadULong(fphalo, &halo.hostHalo,     swap);    // hostHalo(2)
      ReadUInt (fphalo, &halo.numSubStruct, swap);    // numSubStruct(3)
      ReadFloat(fphalo, &halo.Mvir,         swap);    // Mvir(4)
      ReadUInt (fphalo, &halo.npart,        swap);    // npart(5)
      ReadFloat(fphalo, &halo.Xc,           swap);    // Xc(6)
      ReadFloat(fphalo, &halo.Yc,           swap);    // Yc(7)
      ReadFloat(fphalo, &halo.Zc,           swap);    // Zc(8)
      ReadFloat(fphalo, &halo.VXc,          swap);    // VXc(9)
      ReadFloat(fphalo, &halo.VYc,          swap);    // VYc(10)
      ReadFloat(fphalo, &halo.VZc,          swap);    // VZc(11)
      ReadFloat(fphalo, &halo.Rvir,         swap);    // Rvir(12)
      ReadFloat(fphalo, &halo.Rmax,         swap);    // Rmax(13)
      ReadFloat(fphalo, &halo.r2,           swap);    // r2(14)
      ReadFloat(fphalo, &halo.mbp_offset,   swap);    // mbp_offset(15)
      ReadFloat(fphalo, &halo.com_offset,   swap);    // com_offset(16)
      ReadFloat(fphalo, &halo.Vmax,         swap);    // Vmax(17)
      ReadFloat(fphalo, &halo.v_esc,        swap);    // v_esc(18)
      ReadFloat(fphalo, &halo.sigV,         swap);    // sigV(19)
      ReadFloat(fphalo, &halo.lambda,       swap);    // lambda(20)
      ReadFloat(fphalo, &halo.lambdaE,      swap);    // lambdaE(21)
      ReadFloat(fphalo, &halo.Lx,           swap);    // Lx(22)
      ReadFloat(fphalo, &halo.Ly,           swap);    // Ly(23)
      ReadFloat(fphalo, &halo.Lz,           swap);    // Lz(24)
      ReadFloat(fphalo, &halo.b,            swap);    // b(25)
      ReadFloat(fphalo, &halo.c,            swap);    // c(26)
      ReadFloat(fphalo, &halo.Eax,          swap);    // Eax(27)
      ReadFloat(fphalo, &halo.Eay,          swap);    // Eay(28)
      ReadFloat(fphalo, &halo.Eaz,          swap);    // Eaz(29)
      ReadFloat(fphalo, &halo.Ebx,          swap);    // Ebx(30)
      ReadFloat(fphalo, &halo.Eby,          swap);    // Eby(31)
      ReadFloat(fphalo, &halo.Ebz,          swap);    // Ebz(32)
      ReadFloat(fphalo, &halo.Ecx,          swap);    // Ecx(33)
      ReadFloat(fphalo, &halo.Ecy,          swap);    // Ecy(34)
      ReadFloat(fphalo, &halo.Ecz,          swap);    // Ecz(35)
      ReadFloat(fphalo, &halo.ovdens,       swap);    // ovdens(36)
      ReadUInt (fphalo, &halo.nbins,        swap);    // nbins(37)
      ReadFloat(fphalo, &halo.fMhires,      swap);    // fMhires(38)
      ReadFloat(fphalo, &halo.Ekin,         swap);    // Ekin(39)
      ReadFloat(fphalo, &halo.Epot,         swap);    // Epot(40)
      ReadFloat(fphalo, &halo.SurfP,        swap);    // SurfP(41)
      ReadFloat(fphalo, &halo.Phi0,         swap);    // Phi0(42)
      ReadFloat(fphalo, &halo.cNFW,         swap);    // cNFW(43)
 
      //=================================================================================
      // write halo properties
      //=================================================================================
      //printf("%ld %f %f %f %f\n",halo.ID,halo.Mvir,halo.Xc,halo.Yc,halo.Zc);

      //
      if(halo.hostHalo == 0)
	{
	  mhalo[counthalo].ID = halo.ID;
	  ReadULong(fppart, &(npart), swap);
	  printf("read npart %ld:%ld\n",counthalo,npart);
	  mhalo[counthalo].npart = npart;
	  if(mhalo[counthalo].npart != halo.npart)
	    {
	      printf("npart mismatch p:%ld, h:%ld\nExit()\n",mhalo[counthalo].npart,halo.npart);
	      exit(1);
	    }
	  mhalo[counthalo].Particles = malloc(halo.npart*sizeof(particlelist_t));
	  //printf("%ld\n",(long unsigned)npart);
	  for(ipart=0; ipart<halo.npart; ipart++) 
	    {
	      ReadULong(fppart, &(mhalo[counthalo].Particles[ipart].ID), swap);
	      ReadFloat(fppart, &energy, swap);

	    }
	  counthalo++;
	}
      else
	{
	  ReadULong(fppart, &npart, swap);
	  for(ipart=0; ipart<npart; ipart++) 
	    {
	      ReadULong(fppart, &id, swap);
	      ReadFloat(fppart, &energy, swap);
	    }
	}
    } // for(numHalos)
}

/*
 Read a possibly byte swapped integer
 */
int ReadInt(FILE *fptr,int *n,int swap)
{
  /* unsigned char *cptr,tmp; */
  
  /* if(sizeof(int) != 4) */
  /*  { */
  /*   fprintf(stderr,"ReadInt: sizeof(int)=%ld and not 4\n",sizeof(int)); */
  /*   exit(0); */
  /*  } */
  
  if (fread(n,4,1,fptr) != 1)
    return(FALSE);
  /* if (swap) { */
  /*   cptr = (unsigned char *)n; */
  /*   tmp     = cptr[0]; */
  /*   cptr[0] = cptr[3]; */
  /*   cptr[3] = tmp; */
  /*   tmp     = cptr[1]; */
  /*   cptr[1] = cptr[2]; */
  /*   cptr[2] = tmp; */
  /* } */
  return(TRUE);
}

/*
 Read a possibly byte swapped unsigned integer
 */
int ReadUInt(FILE *fptr,unsigned int *n,int swap)
{
  /* unsigned char *cptr,tmp; */
  
  /* if(sizeof(int) != 4) */
  /*  { */
  /*   fprintf(stderr,"ReadInt: sizeof(int)=%ld and not 4\n",sizeof(int)); */
  /*   exit(0); */
  /*  } */
  
  if (fread(n,4,1,fptr) != 1)
    return(FALSE);
  /* if (swap) { */
  /*   cptr = (unsigned char *)n; */
  /*   tmp     = cptr[0]; */
  /*   cptr[0] = cptr[3]; */
  /*   cptr[3] = tmp; */
  /*   tmp     = cptr[1]; */
  /*   cptr[1] = cptr[2]; */
  /*   cptr[2] = tmp; */
  /* } */
  return(TRUE);
}

/*
 Read a possibly byte swapped unsigned long integer
 */
int ReadULong(FILE *fptr,unsigned long *n,int swap)
{
  /*   unsigned char *cptr,tmp; */
  
  /* if(sizeof(unsigned long) == 4) */
  /*  { */
  /*   if (fread(n,4,1,fptr) != 1) */
  /*     return(FALSE); */
  /*   /\* if (swap) { *\/ */
  /*   /\*   cptr = (unsigned char *)n; *\/ */
  /*   /\*   tmp     = cptr[0]; *\/ */
  /*   /\*   cptr[0] = cptr[3]; *\/ */
  /*   /\*   cptr[3] = tmp; *\/ */
  /*   /\*   tmp     = cptr[1]; *\/ */
  /*   /\*   cptr[1] = cptr[2]; *\/ */
  /*   /\*   cptr[2] = tmp; *\/ */
  /*   /\* } *\/ */
  /*  } */
  /* else if(sizeof(unsigned long) == 8) */
  /*  { */
    if (fread(n,8,1,fptr) != 1)
      return(FALSE);
    /* if (swap) { */
    /*   cptr = (unsigned char *)n; */
    /*   tmp     = cptr[0]; */
    /*   cptr[0] = cptr[7]; */
    /*   cptr[7] = tmp; */
    /*   tmp     = cptr[1]; */
    /*   cptr[1] = cptr[6]; */
    /*   cptr[6] = tmp; */
    /*   tmp     = cptr[2]; */
    /*   cptr[2] = cptr[5]; */
    /*   cptr[5] = tmp; */
    /*   tmp     = cptr[3]; */
    /*   cptr[3] = cptr[4]; */
    /*   cptr[4] = tmp; */
    /* } */
  /*  } */
  /* else */
  /*  { */
  /*   fprintf(stderr,"ReadULong: something wrong...cannot read long\n"); */
  /*   exit(0); */
  /*  } */
  
  return(TRUE);
}

/*
 Read a possibly byte swapped floating point number
 Assume IEEE format
 */
int ReadFloat(FILE *fptr,double_t *n, int swap)
{
  /*  unsigned char *cptr,tmp; */
  
  /* if(sizeof(float) != 4) */
  /*  { */
  /*   fprintf(stderr,"ReadFloat: sizeof(float)=%ld and not 4\n",sizeof(float)); */
  /*   exit(0); */
  /*  } */
  
  if (fread(n,4,1,fptr) != 1)
    return(FALSE);
  /* if (swap) */
  /*  { */
  /*   cptr = (unsigned char *)n; */
  /*   tmp     = cptr[0]; */
  /*   cptr[0] = cptr[3]; */
  /*   cptr[3] = tmp; */
  /*   tmp     = cptr[1]; */
  /*   cptr[1] = cptr[2]; */
  /*   cptr[2] = tmp; */
  /*  } */
  return(TRUE);
}

